# 1장 상태가 있는 스트림처리 소개
## Flink 란?
* 분산 스트림 처리 오픈소스 소프트웨어
* 상태가 있는 스트림 처리(Stateful Stream Processing) 프레임워크
* 대규모 트래픽을 잘 처리할 수 있고, 강한 내결함성 가지며, exactly-once를 보장
## 스트림 데이터란?
* 다양한 소스에서 생성된 데이터의 지속적인 흐름, 기술적인 정의로 unbounded data를 뜻한다고 볼 수 있음

|    | bounded data          | unbounded data                       |
|----|-----------------------|--------------------------------------|
| 정의 | 완결된 형태의 정적인 데이터       | 데이터의 크기가 정해져 있지 않고 끊임없이 생성되는 무한의 데이터 |
| 예시 | 하루치 로그, 특정 기간 수집된 데이터 | IoT 기기 데이터, SNS 타임 피드, 증권 거래 주문      |
## 스트림 프로세싱이란?
### 기존 데이터 프로세싱 아키텍처와 비교
|           | 전통적인 데이터 프로세싱                            | 스트림 프로세싱                             |
|-----------|------------------------------------------|--------------------------------------|
| 데이터 처리 방식 | 트랜잭션 처리<br/>일괄 처리(배치)                    | 실시간 스트림 프로세싱                         |
| 처리하는 데이터  | bounded data                             | unbounded data                       |
| 특징        | 지연 존재<br/>높은 데이터 처리 일관성               | 실시간성 보장<br/>데이터 왜곡 가능성(현재 완화됨)    |
| 활용        | 대규모 정적 데이터 통계 및 분석<br/>ETL 작업, 데이터 웨어하우스 | 이벤트 스트림 처리<br/>데이터 파이프라인<br/>스트리밍 분석 |
### 스트림 프로세싱의 종류
|     | ESP(Event Stream Processing)           | CEP(Complex Event Processing)         |
|-----|----------------------------------------|---------------------------------------|
| 정의  | 스트림 데이터로부터의 이벤트 변화를 단순 수집 혹은 분석        | 복합적인 스트림 데이터를 실시간 분석하여 이벤트 패턴 감지 및 처리 |
| 예시  | 실시간 로그 처리<br/>실시간 통계<br/>실시간 사용자 행동 분석 | 사기 거래 탐지<br/>이상 징후 파악                 |

### 상태가 있는 스트림 처리(Stateful Stream Processing)
* 무한 이벤트 스트림을 처리하는 애플리케이션 설계 패턴
* 상태가 있는 애플리케이션은 이벤트를 수신한 후 상태에서 데이터를 읽거나, 상태에 데이터를 쓰는 연산을 수행
* 이론적으로 상태를 프로그램 변수, 로컬 파일, 내부 혹은 외부 DB같은 여러 저장소에 저장하고 접근할 수 있음

#### 이벤트 주도 애플리케이션
* 이벤트 스트림을 입력받아 특정 비즈니스 로직을 처리하는 애플리케이션
* REST 호출 대신 이벤트 로그를 통해서 서로 통신하고, 상태를 로컬에서 관리하여 실시간 처리에 적합

#### 데이터 파이프라인
* 이벤트 로그를 사용해 데이터 변경 내용을 필요한 곳에 분산
* 저지연으로 데이터를 처리, 보강, 집계해서 도착지에 전송

#### 스트리밍 분석
* 실시간 데이터 수집과 처리를 통한 실시간 분석

#### Flink의 스트림 처리
* 상태를 로컬 메모리나 임베디드 DB에 저장하고, 원격의 신뢰성 있는 저장소에 체크포인트를 주기적으로 기록해 내결함성을 갖음
* 세이브포인트 기능을 지원하여 상태를 잃지 않고 애플리케이션을 업그레이트하거나 수평 확장 가능
* Flink는 exactly-once 수준의 상태 일관성을 보장
* 이벤트 시간을 관리하여 일정한 처리 결과를 보장하고, 데이터 왜곡을 방지함
* 다양한 외부 시스템과 연결할 수 있는 커넥터 제공
* scale-out이나 job 관리가 용이한 강력한 운영 환경 제공
* SQL 형태의 API 제공

#### Flink의 exactly once 보장 원리
* Two phase commit (2PC)
  * 외부 시스템의 트랜잭션 기능과 연계해서 commit을 2단계로 하는 것
* 분산 스냅샷 기반의 체크포인트
  * 연산을 수행하면서 체크포인트를 전파하여 각 단계가 보유한 로컬 상태의 스냅샷을 보관
* Flink가 exactly once를 보장하기 위해서는 source와 sink에 연결된 외부 시스템도 exactly once나 멱등성을 보장해야 함

## 스트림 프로세싱의 발전 과정
### Lambda 아키텍처
* 2010년대 빅테크 기업에서 실시간 통계에 대한 요구가 확산
* 최초로 인기를 끌게된 스트림 프로세싱 소프트웨어였던 Storm은 실시간 처리가 가능했으나 낮은 정확도를 가지고 있었음
* 이러한 단점을 보완하고자 Storm으로 실시간 통계를 보여주고, Hadoop이나 Spark로 후보정을 하는 Lambda 아키텍처가 유행
### Kappa 아키텍처
* Kafka와 같은 exactly once를 보장하는 영구적인 이벤트 스트림 플랫폼이 등장하여 유행하기 시작함
* Lambda 아키텍처가 2개의 파이프라인을 유지해야하는 복잡성에 의문이 제기되면서 Kappa 아키텍처가 제안됨
* Kafka 로부터 이벤트를 읽어들이게 하고 스트림 처리 계층만 남긴 채, 장기 저장 계층을 두어 보정이 필요한 경우 장기 저장 계층으로 이를 복구하는 식으로 해결한다는 아이디어
### 3세대 오픈소스 스트림 프로세서 등장
* Kappa 아키텍처를 잘 구현한 실시간 스트림 프로세싱 소프트웨어가 등장하기 시작함
* Flink도 그 중 하나였고 초창기에는 부실했으나 지속적인 발전으로 현재 스트림 프로세싱의 표준이 됨

## Flink 빠르게 살펴보기
* 다운로드 및 실행
``` bash
$ wget https://dlcdn.apache.org/flink/flink-1.20.1/flink-1.20.1-bin-scala_2.12.tgz

$ tar xvfz flink-1.20.1-bin-scala_2.12.tgz

$ cd flink-1.20.1
$ ./bin/start-cluster.sh
```
* 대시보드 주소: http://localhost:8081
* job 추가하기
``` bash
$ ./bin/flink run -c examples.jar
```

* 종료
``` bash
$ ./bin/stop-cluster.sh
```

# 2장 스트리밍 처리 기초
## 데이터플로우(DataFlow) 프로그래밍 소개
### 데이터플로우 그래프 
* 데이터플로우 그래프는 개념적 수준에서 계산 로직의 모습을 그린 것, 방향성 그래프 형태로 표현됨
* 맵리듀스와 비슷하게 추상화된 처리 로직을 기반으로 실제 처리는 여러 서버에서 분산 처리됨
### 데이터 병렬화와 태스크 병렬화
* 데이터 병렬화: 동일 연산을 수행하는 태스크를 각 입력 파티션에 할당해 병렬 처리
* 태스크 병렬화: 같거나 다른 데이터에 여러 연산을 수행하는 태스크를 할당
### 데이터 교환 전략
* 전진 전략: 한 태스크로 들어온 데이터를 다른 태스크 쪽으로 보냄
* 브로드캐스트 전략: 모든 레코드를 연산자의 모든 병렬 태스크로 내보낸다.
* 키 기반 전략: 데이터를 키 기준으로 모아 같은 키 값을 가진 데이터는 같은 태스크에 모이도록 보장
* 랜덤 전략: 각 계산 태스크의 부하를 균등하게 분산시키고자 모든 연산자 태스크로 데이터를 균등하게 분배
## 병렬 스트림 처리
### 지연과 처리율
#### 지연
* 이벤트를 처리하는 데 걸린 경과 시간
* 스트림 처리의 핵심이며 실시간 처리에 있어 필수적인 요소
#### 처리율
* 시스템 처리량을 측정하는 메트릭
* 처리율은 단위 시간당 처리한 이벤트 개수나 연산 호출 횟수를 측정
* 처리율은 이벤트 도착 비율에 의존하기 때문에 낮은 처리율이 꼭 나쁜 성능을 나타내지 않음
* backpressure: 시스템이 처리할 수 있는 비율보다 높게 데이터를 계속 받으면 버퍼링도 불가능하게 돼 데이터 유실이 일어날 수 있고 이러한 상황을 뜻함
#### 지연과 처리율
* 부하가 없다면 지연은 최적
* 부하가 증가하면 지연이 늘어나게 될 것이고 전체 처리율일 떨어지게 됨
* 스트림을 병렬로 처리하면 지연을 줄일 수 있게 된다.

### 데이터 스트림 연산
* 상태가 있는 연산과 상태가 없는 연산이 따로 있음
* 상태가 있는 경우 병렬성과 내결함성을 유지하는 것이 쉽지 않다.
#### 데이터 인입과 방출
* 데이터 인입
  * 외부 소스에서 원시 데이터를 가져와 스트림 처리에 맞는 형식으로 변환하는 연산
  * 이러한 연산을 데이터 소스라고 함
* 데이터 방출
  * 데이터를 수신할 외부 시스템의 소비 형태에 맞게 데이터 형식을 변환해 내보내는 연산
  * 이러한 연산을 데이터 싱크라고 함
* 상태를 갖지 않는 연산
#### 변환 연산
* 단일 경로 연산으로 각 이벤트 데이터에 변환 연산을 적용한 후 변환된 이벤트를 새 출력 스트림으로 내보냄
* 상태를 갖지 않는 연산
#### 롤링 집계 연산
* 합계, 최솟값, 최댓값과 같은 집계 연산
* 이벤트가 들어올 때마다 계속해서 상태를 갱신함
* 집계 연산은 결합 법칙과 교환 법칙이 성립해야 함
  * 그렇지 않으면 집계 연산자는 모든 이벤트 스트림 이력을 저장해야 한다.
#### 윈도우 연산
* 스트림 조인이나 평균 함수와 같은 전체 집계 연산의 경우 여러 이벤트를 함께 처리해야 함
* 전체 집계 연산을 무한 스트림에서 수행하려면 각 연산은 자신의 상태에 보관 가능한 수준의 데이터양을 제한하여야 하며, 이때 윈도우 연산을 이용함
* 윈도우 연산은 데이터를 버퍼링하는 형태로 동작함
##### 텀플링 윈도우
* 고정 길이에 서로 겹치지 않는 버킷으로 이벤트를 할당
* 이벤트가 윈도우 경계를 넘으면 이전에 윈도우에 있던 모든 이벤트를 평가 함수로 보낸다.
* 윈도우 크기 기준은 갯수 기반이 될 수도 있고, 시간 기반이 될 수도 있음
##### 슬라이딩 윈도우
* 서로 겹치는 고정 길이의 버킷으로 이벤트를 할당
##### 세션 윈도우
* 텀블링이나 슬라이딩 윈도우로 적용할 수 없는 현실 세계 시나리오에 유용함
* 인접 시간 동안 발생한 연속 이벤트로 세션을 구헝함
* 비활동 시간인 세션 격차 값으로 세션이 종료됐다고 판단하며 윈도우를 닫는다.
## 시간 시멘틱
### 스트리밍 처리에서 1분
* 처리 시간: 이벤트가 수신된 시간
* 이벤트 시간: 이벤트가 실제 발생한 시간
### 워터마크
* 이벤트가 더 지연되지 않고 도착할 것이라고 확신할 수 있는 시점을 가리키는 타임스탬프 값
* 연산자가 위터마크를 수신하면 일정 기간 발생한 모든 이벤트의 시간이 감지됐다고 간주하여 늦게 도착한 이벤트를 드롭함
* 드롭된 이벤트를 처리하는 별도의 코드를 제공할 수 있다.
### 처리 시간과 이벤트 시간
* 이벤트 시간은 결정적 결과를 보장하며 지연된 이벤트도 처리 가능하고 순서를 보장한다.
* 이벤트 시간이 있는데 처리 시간을 고민해야 하는 이유: 속도가 중요한 애플리케이션의 경우 장점이 있음
## 상태와 일관성 모델
### 상태가 있는 연산자를 제공하기 위한 도전 과제
* 상태 관리
  * 상태 관리를 효율적으로 해야함
  * 상태를 갱신할 때 상태를 보호해야 함
* 상태 분할
  * 병렬로 처리할 때 처리 결과가 상태와 입력 이벤트 모두에 의존하므로 복잡해진다.
  * 키로 상태를 분할하여 각 파티션별로 독집적으로 관리하도록 하낟.
* 상태 복구
  * 장애 시에도 정확한 결과를 내보내야 함
### 태스크 실패
* 아래 3가지의 처리 단계에서 실패가 발생할 수 있고 복구시 상태가 유실되지 않아야 함
  * 이벤트를 수신해 로컬 버퍼에 저장하는 경우
  * 경우에 따라 내부 상태 갱신
  * 출력 레코드 생산
### 결과 보장
* most once
* least once
* exactly once
* end to end exactly once


