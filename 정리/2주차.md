# 3장 아파치 플링크 아키텍처
## 시스템 아키텍처
* 플랭크는 상태가 있는 병렬 스트림을 처리할 수 있는 분산 시스템
* 클러스터 관리, 고가용성 보장 등의 기능들은 플링크가 직접 구현하지 않고 기존 클러스터 인프라와 서비스를 이용한다.
  * 아파치 메소스, YARN, 쿠버네티스와 통합 가능
  * 신뢰성 있는 분산 저장소를 따로 제공하지 않고 HDFS나 S3 같은 파일 시스템을 이용함
  * 고가용성에서 필요한 리더 설출은 아파치 주키퍼를 사용

### 플링크 컴포넌트
#### 잡매니저(JobManager)
* 애플리케이션의 실행을 제어하는 마스터 프로세스
* 잡매니저는 단일 애플리케이션을 제어함
* 잡그래프라 부르는 논리 데이터플로우 그래프와 애플리케이션에 필요한 모든 자원을 포함한 JAR 파일로 구성됨
* 잡매니저는 잡그래프를 실행그래프라 부르는 물리 데이터플로우 그래프로 변환함
* 잡매니저는 리소스매니저에서 태스크 실행에 필요한 자원(태스크매니저 슬롯)을 요청함
* 충분한 태스크 슬롯을 할당받으면 잡매니저는 작업을 처리할 태스크로 실행그래프를 배포함
* 잡매니저는 런타임 간에 체크포인트를 조율하고 중앙에서 제어해야 하는 모든 동작을 책임 진다.
#### 리소스매니저(ResourceManager)
* YARN, 메소스, 쿠버네티스, 독립형 클러스터와 같은 각 환경에서 자원을 관리할 수 있도록 하는 역할
* 플링크의 실행 단위인 태스크매니저 슬롯을 관리하는 책임을 가짐
* 잡매니저가 태스크매니저 슬롯을 요청하면 유휴 슬롯을 잡매니저에게 제공함
* 잡매니저에게 제공할 만큼 충분한 슬롯을 갖고 있지 않다면 자원 제공자에게 태스크매니저 프로세스를 실행할 컨테이너를 제공하도록 요청함
* 유휴 태스크매니저를 종료해 컴퓨팅 자원을 반환하는 책임도 가짐
#### 태스크매니저(TaskManager)
* 플링크의 워커 프로세스
* 일반적으로 한 플링크 클러스터는 여러 태스크매니저를 갖고, 각 태스크매니저는 여러 슬롯을 제공함
* 슬롯의 갯수는 태스크매니저가 실행할 수 있는 최대 태스크 개수를 의미함
* 태스크매니저를 시작할 때 자신의 모든 슬롯을 리소스매니저에 등록함
* 리소스매니저에서 슬롯 제공 지시가 내려오면 태스크매니저는 하나 이상의 슬롯을 잡매니저에게 제공, 잡매니저는 실행 태스크를 이 슬롯에 할당
* 태스크가 다른 태스크매니저에 있는 태스크와 통신이 필요하면 태스크매니저를 통해 데이터를 교환
#### 디스패처(dispatcher)
* 여러 잡을 실행할 때 사용하며, 애플리케이션을 제출할 수 있는 REST 인터페이스를 제공
* 사용자가 디스패처에 애플리케이션을 제출하면 디스패처는 잡매니저를 시작하고 애플리케이션을 잡매니저에 넘긴다.
* 이 REST 인터페이스로 방화벽 뒤에 있는 클러스터도 HTTP를 통해 디스패처 서비스를 제공할 수 이음

![플링크 아키텍처](https://nightlies.apache.org/flink/flink-docs-master/fig/processes.svg)

### 애플리케이션 배포
#### 프레임워크 방식
* 플링크 애플리케이션을 하나의 JAR 파일로 패키징한 후 클라이언트를 이용해 제출하는 방식
* 제출된 애플리케이션은 플링크의 어느 서비스로 제출되든 즉시 실행을 보장
#### 라이브러리 방식
* 플링크 애플리케이션을 도커 이미지처럼 애플리케이션에 특화된 컨테이너 이미지로 만드는 방식
* 이 컨테이너 이미지는 잡매니저와 리소스매니저를 실행할 코드를 포함하고 있음
* 이 이미지에서 시작한 컨테이너는 태스크매니저를 시작하며, 태스크매니저는 리소스매니저에 연결해 슬롯을 등록한다.
* 쿠버네티스와 같은 외부 자원 관리자가 컨테이너 이미지를 시작시키면 장애가 발생할 때 컨테이너 재시작을 보장

### 태스크 실행
* 태스크매니저는 JVM 안에서 여러 태스크를 멀티스레드로 동작할 수 있음
* 같은 연산자(데이터 병렬화), 다른 연산자(태스크 병렬화), 또는 다른 애플리케이션(잡 병렬화) 태스크가 태스크매니저의 태스크가 될 수 있다.
* 태스크매니저는 데이터 처리 슬롯 개수 설정을 제공해 동시 실행 가능한 태스크 개수를 제어함
* 각 연산의 병렬 값을 설정해서 해당 연산을 동시에 몇 개의 태스크로 수행할지 정할 수 있음
* 태스크매니저에 할당하는 슬롯 개수에 따라 멀티스레드 혹은 멀티프로세스 형태로 작업 수행이 가능

![태스크 실행](https://nightlies.apache.org/flink/flink-docs-master/fig/slot_sharing.svg)

### 고가용성 설정
* 24/7 원칙에 따라 설계됨
#### 태스크매니저 실패
* 태스크매니저에 장애가 생기면 할당되어 있는 슬롯 만큼 전체 클러스터의 가용 슬롯이 줄어드는 것
* 잡매니저가 리소스매니저에게 슬롯을 요청했을 때 가용 슬롯이 부족하다면 애플리케이션을 재실행할 수 없게 된다.
* 애플리케이션 재시작 전략은 잡매니저가 얼마나 자주 애플리케이션을 재시작하고 재시작 시도 동안 얼마나 오래 기다릴지 결정
#### 잡매니저 실패
* 잡매니저는 완료한 체크포인트 정보와 스트리밍 애플리케이션 실행 제어 관련 메타데이터를 유지함
* 잡매니저가 사라지면 스트리밍 애플리케이션은 더 이상 레코드를 처리할 수 없게 됨
* 잡매니저는 SPOF이며 플링크는 죽은 잡매니저의 메타 데이터를 다른 잡매니저에게 넘기는 방식으로 이를 해결함
* 플링크의 고가용성은 조율과 합의 기능을 제공하는 주키퍼의 도움을 받음
* 실행에 필요한 모든 메타 데이터를 저장해놓고 주키퍼에 해당 데이터 위치를 저장하여 새로운 잡매니저 실행에 사용함

## 플링크 내부의 데이터 전송
* 태스크매니저는 전송 태스크에서 수신 태스크까지 데이터를 전송하는 역할을 수행함
* 태스크매니저는 데이터를 네트워크로 전송하기 전에 버퍼해두었다가 보냄
* 각 태스크는 전송용 버퍼와 수신용 버퍼가 필요함
* 데이터를 셔플링하거나 브로드캐스트한다면 전송 태스크는 연결된 수신 태스크의 개수만큼 버퍼를 가지고 있어야 함
* 같은 태스크매니저 내에서의 데이터 전송은 큐를 사용하기 때문에 네트워크 통신을 유발하지 않음
### 크레딧 기반 흐름 제어
* 버퍼링에 의한 지연을 줄이기 위한 기술
* 수신 태스크는 전송 태스크에 크레딧이라는 것을 부여함
  * 크레딧은 수신 태스크가 데이터를 수신하려고 예약한 네트워크 버퍼 개수
* 수신 태스크가 전송 태스크에 크레딧을 알려주면 전송 태스크는 부여받은 크레딧만큼의 버퍼와 백로그 크기를 수신 태스크에 전송함
  * 백로그 크기란 가득차서 전송할 준비가 된 네트워크 버퍼 수
* 수신 태스크는 예약한 버퍼로 도착한 데이터를 처리하고 전송 태스크의 백로그 크기를 이용해 연결돼 있는 모든 전송 태스크의 다음 크레딧을 우선순위 방식으로 정함
* 크레딧 기반 흐름 제어는 수신 태스크가 데이터를 수신할 준비가 되면 바로 데이터를 전송하기 때문에 지연 시간을 줄일 수 있다.

### 태스크 체이닝
* 특정 조건에서 로컬 통신 부하를 줄여주는 기법
  * 두 개 이상의 연산자가 동일한 병렬값으로 설정되어 있어야 함
  * 연산자들이 로컬 포워드 채널로 연결되어 있어야 함
* 조건이 만족되면 플링크는 모든 연산을 하나의 태스크로 합쳐서 수행함
* 상황에 따라서는 태스크 체이닝을 사용하지 않는 경우가 효율적일 수 있다.

## 이벤트 시간 처리
### 타임스탬프
* 타임스탬프는 이벤트의 발생 시점을 나타내는 값
* 레코드의 타임스탬프가 스트림 속도와 얼추 비슷하다면 타임스탬프의 의미를 애플리케이션이 자유롭게 정할 수 있다. (커스텀하게 설정할 수 있다는 의미)

### 워터마크
* 워터마크는 태스크의 이벤트 시간 시계가 앞으로만 흘러가고 역행하지 않는다.
* 워터마크는 타임스탬프 값이며, 워터마크 이후에 오는 모든 레코드의 타임스탬프는 이 워터마크보다 커야 함을 의미함
* 워터마크는 애플리케이션 결과의 완성도와 지연을 애플리케이션이 제어할 수 있게 한다.
  * 워터마크가 짧은 주기로 생성된다면 처리 지연을 줄일 수 있고
  * 워터마크가 긴 주기로 생성된다면 결과의 완성도를 높인다.

![워터 마크](https://nightlies.apache.org/flink/flink-docs-master/fig/stream_watermark_in_order.svg)

### 워터마크 전파와 이벤트 시간
* 태스크는 타이머 서비스를 가지고 있으며 워터마크가 도착하는 시점 이 타이머를 활성화하여 특정한 작업을 수행하게 할 수 있다.
  * 예를 들면 윈도우 닫기
* 태스크는 입력 파티션에서 워터마크를 받으면 해당 파티션의 현재 워터마크 값과 새 값을 비교해서 최대값을 새로운 워터마크로 갱신함
* 태스크는 모든 입력 파티션의 워터마크 중 최솟값으로 이벤트 시간 시계 값을 갱신함
* 이 순간 태스크는 등록된 타이머 중 시간이 만료된 모든 타이머를 활성화한다. 관련된 작업을 처리함
* 마지막에는 연결된 모든 출력 파티션으로 새 워터마크를 내보낸다.
* 입력 스트림 간 받은 이벤트의 타임스탬프는 동기화가 되어 있어야 한다.
### 타임스탬프 할당과 워터마크 생성
* 보통 스트림 애플리케이션으로 스트림 데이터가 들어올 때 타임스탬프를 할당하고 워터마크를 생성함
#### 소스에서 생성
* SourceFunction을 통해 생성 가능
* 유휴 상태로 선언할 수 있는데 이 경우 플링크가 해당 파티션을 워터마크 계산에서 제외함
#### 주기적인 할당자
* AssignerWithPeriodicWatermarks
#### 구두점 할당자
* AssignerWithPunctuatedWatermarks
## 상태 관리
* 상태 일관성과 관련된 모든 문제, 실패 처리와 저장소의 효과적인 접근 등은 플링크가 책임지므로 개발자는 애플리케이션 로직에만 집중할 수 있다.
* 플링크가 연산자의 상태를 알 수 있게 하려면 연산자는 자신이 사용할 상태를 등록해야 한다.
  * 상태의 종류에는 연산자 상태와 기 상태 두 종류가 있고, 스코프에 따라 접근이 제한된다.

### 연산자 상태
* 연산자 상태의 스코프는 연산자 태스크 하나
  * 한 태스크가 처리하는 모든 레코드가 동일 상태에 접근할 수 있다는 의미임
* 연산자 상태 종류
  * 리스트 상태: 리스트의 요소들로 상태를 표현
  * 유니온 리스트 상태: 리스트 상태를 나타내는 것은 같음, 그러나 장애 복구하거나 애플리케이션을 세이브포인트에서 시작할 때 차이가 있음
  * 브로드캐스트 상태: 연산자의 모든 태스크 상태가 동일한, 특수한 경우에 사용하는 연산자 상태
### 키 상태
* 레코드의 각 키 값별로 유지하고 접근할 수 있는 상태
* 키 상태 종류
  * 값 상태: 임의 타입의 값을 키별로 저장함
  * 리스트 상태: 각 키별로 값 리스트를 저장
  * 맵 상태: 키별로 키-값 맵을 저장한다.

### 상태 백엔드
* 상태가 있는 연산자 태스크는 들어오는 레코드마다 상태를 읽고 갱신한다.
* 짧은 지연으로 레코드를 처리하려면 효율적인 상태 접근이 매우 중요하기 때문에 연산자 태스크는 상태를 로컬에 유지함
* 상태의 정확한 저장, 접근, 유지는 상태 백엔드라 부르는 플러그인 가능한 컴포넌트가 결정함
* 상태 백엔드는 로컬 상태 관리와 원격 저장소에 상태를 체크포인팅하는 두 가지 책임을 가짐
* 로컬에 JVM heap 구조로 객체를 저장하여 관리하는 형태와 RocksDB에 저장해서 관리하는 형태가 있음

#### 상태가 있는 연산자의 수평 확장
* 효율적인 상태 재분배를 위해 키를 키 그룹으로 구조화하여 분배함

## 체크포인트, 세이브포인트, 상태 복구
### 일관성 체크포인트
* 플링크의 복구 방식은 애플리케이션 상태의 일관성 체크포인트에 기반을 두고 있다.
* 일관성 체크포인트란 모든 태스크가 정확히 동일한 시점에 각 태스크의 상태를 복사하는 것
  1. 모든 입력 스트림의 인입을 정지
  2. 현재 처리 중인 데이터가 완료되기까지 대기
  3. 각 태스크의 상태를 복사해 원격의 영구 저장소로 체크포인트를 지정. 모든 태스크가 상태 복사를 끝내면 체크포인팅도 완료
  4. 입력 스트림 인입 재개
### 체크포인트에서 복구
* 장애가 발생하면 플링크는 가장 최신 체크포인트를 사용해 일관성 있게 애플리케이션 상태를 복구하고 레코드 처리를 재시작함
  1. 전체 애플리케이션 재시작
  2. 상태가 있는 모든 태스크 상태를 가장 최신의 체크포인트로 재설정
  3. 모든 태스크 처리 재시작
* 모든 연산자가 체크포인팅을 수행하고 모든 상태를 복구한 후 모든 입력 스트림의 위치가 체크포인팅 수행 당시 마지막으로 소비했던 위치로 재설정된다면 exactly once 보장
* 데이터 소스의 입력 스트림 재설정 여부는 데이터 소스의 구현과 외부 시스템이나 데이터 소스 스트림이 데이터를 가져오는 인터페이스에 달려있다.
* 결론적으로 애플리케이션의 모든 입력 스트림이 재설정 가능한 데이터 소스에서 데이터를 소비하면 exactly once 보장

### 플링크의 체크포인트 알고리즘
* 플링크는 챈디-램포트 알고리즘을 기반으로 분산 스냅샷 체크포인팅을 구현함
* 이 알고리즘은 애플리케이션 전체를 정지하지 않고 체크포인트와 데이터 처리 간의 결합을 분리한다.
* 배리어라는 레코드를 전파해가면서 체크포인트 생성함
* 배리어가 수신된 파티션은 모든 파티션에서 배리어가 수신되어 처리되기 전까지 입력을 받지 않고 버퍼링함
* 배리어가 싱크에 도착하면 체크포인팅 완료를 진행함
### 체크포인트가 성능에 미치는 영향
* 플링크는 특정 조건에서 성능상의 충격을 완화할 수 있도록 체크포인트 알고리즘을 변형함
* 비동기 체크포인팅을 도입하여 지연을 줄임, RocksDB는 중분 체크포인트 기능도 존재
  * 이거는 데이터 유실 위험이 있는거 아닌가?
* 배리어 정렬 시 배리어 도착 후 들어오는 레코드를 버퍼에 쌓는 대신 계속 처리하도록 플링크에 설정하는 기능도 존재
  * 이 경우 exactly once가 아닌 at least once가 됨

![체크포인트 ](https://nightlies.apache.org/flink/flink-docs-master/fig/stream_unaligning.svg)


### 세이브포인트
* 로직은 체크포인트와 같으나 몇 가지 메타데이터가 추가되어고 사용자가 수동으로 생성하는 형태
### 세이브포인트 사용
* 애플리케이션과 호환성을 가진 세이브포인트가 있다면 세이브포인트에서 시작할 수 있다.
* 체크포인트 장애 복구는 동일 클러스터에서 동일 설정으로 동일 애플리케이션을 시작하는 것
* 세이브포인트는 핫픽스나 A/B 테스트 같은데 사용하거나 scale-out, 마이크레이션 등에 사용하기 용이하다.
* 또한 애플리케이션의 상태를 이력으로 남기거나 아카이빙에 사용할 수도 있음
### 세이브포인트에서 애플리케이션 시작
* 애플리케이션을 세이브포인트에서 재실행하기 위해서는 세이브포인트와 일치하는 식별자와 상태 이름을 가진 연산자를 포함해야만 가능함
  * 따라서 연산자에 고유 식별자를 직접 부여하는 것이 좋음